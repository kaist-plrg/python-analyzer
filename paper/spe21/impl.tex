\section{Implementation}\label{sec:impl}
Describe the structure of our code transformation tool.

We implemented the code transformation rule for distributed training in Scala,
and our work is available at https://github.com/kaist-plrg/python-analyzer.
The implementation is divided into 4 parts:
Parser, Class Hierachy Analysis,
Training API Pattern Analysis, and Transformer.
(...TODO:system architecture diagram...)

\subsection{Parser}
Describe detailed explanation of Parser.

(brief introduction to the parser)

Parser convert the code in string format into AST.
Rather than using Python AST module, we implemented parser for our tool.
We use scala packrat parser to follow the Python Language Reference
where full grammar specification is written in the form of mixture of EBNF and PEG.

\subsection{Class Hierarchy Analyzer}
Describe detailed explanation of CHA.

(necessity of CHA)

When building a TensorFlow model, there can be user defined classes
that extend some classes in the TensorFlow library.
To transform the TensorFlow model correctly,
we need to analyze the subclass relations of user defined classes.
Therefore, we analyze the class hierarchy before transforming the model.

(explanation of full name)
(TODO: need to check)

In class hierarchy analysis, each class name is expressed as fully qualified name.
Here, fully qualified name of a class means qualified name\cite{???}
on the basis of top of the package.
That is, the path to the module where the class is defined
is used to express the fully qualified name of the class.
By using the fully qualified name, the same class name in different module
can be discriminated.

(how CHA work)

When class is declared, subclass relation is explicitly specified.
We collect all of this information in the class definition,
and we build a directed graph of subclass relation
where the node is fully qualified name and the directed edge exists
from the fully qualified name of child class to that of parent class.
Accordingly, to figure out whether some class X is subclass of some class Y,
we check whether there exists some path from the fully qualified name of X
to that of Y in the graph.

\subsection{Training API Pattern Analyzer}
Describe detailed explanation of TAPA.

(necessity of TAPA)

As mentioned in Section 2.1, user can choose which APIs to use
when building model using TensorFlow library.
However, different transformation rule should be applied
to different usage pattern of training API.
To apply appropriate rule to each model, we analyze the training API pattern.

(categories of TAP)

First, we categorized the training API pattern into 4 categories:
low-level API pattern and high-level API pattern using TensorFlow version 1, and
low-level API pattern and high-level API pattern using TensorFlow version 2.
Session/MonitoredSession is low-level API using TensorFlow version 1,
Estimator is high-level API using TensorFlow version 1,
DistributedGradientTape is low-level API using TensorFlow version 2,
and Keras is high-level API using TensorFlow version 2.

(how TAPA work)

Each category has unique pattern of using training API.
For example, Keras pattern is 1) making instance of model and
2) call compile and fit method of that model.
Conversly, if call expressions of the method model.compile and model.fit are detected
where model is an instance of subclass of Model class in TensorFlow library,
we categorize it as Keras pattern.

(result of TAPA)

By using training API pattern analyzer, we can figure out the API pattern.
However, it is possible that model uses more than one categories of API pattern
such as using both low-level and high-level APIs.
In this case, we reject to transform because transformation rule assumes
that each model uses only one training API pattern.

\subsection{AST Transformer}
Describe detailed explanation of AST Transformer.

In transformation, it takes results of class hierarchy analysis
and training API pattern analysis, and it transforms the code
according to the rule mentioned in Section 3.2.
Because of dynamic behaviors of Python, we give up soundness
to get more complete result.
We leaves warning log with some suggestions
when transformation rule is potentially inaccurate.

