\section{Code Transformation for Distributed Training}\label{sec:trans}
\subsection{Python Abstract Syntax}\label{sec:pysyn}

We first define the abstract syntax for Python programming language.
The syntax of Python is described in the Python Language Reference \cite{pythonref}.
The reference provides a full grammar specification based on the extended PEG,
and detailed explanation of syntatic components in each section.
We manually examined the grammar and the details
to define the Python abstract sytax.
The syntax is composed of three syntactic components: expressions, statements,
and top-level components.

\begin{tabular}{lrll}
  \nmodule & := & \mul{\nstmt} ~ \ntypignore & \desc{ModuleDef} \\
  \nstmt & ::= & \decolist ~ \kdef ~ \nid ~ \sparen{\nargs} ~ \op{(\krightarrow ~ \nexpr)} ~ \kcolon ~ \optypcomm ~ \mul{\nstmt} & \desc{FunDef} \\ 
  & $|$ & \decolist ~ \kclass ~ \nid ~ \sparen{\mul{\nexpr} \mul{\nkeyword}} ~ \kcolon ~ \mul{\nstmt} & \desc{ClassDef} \\
  & $|$ & \mul{\nexpr} ~ \oassign ~ \nexpr ~ \optypcomm & \desc{Assign} \\
  & $|$ & \optypcomm ~ \kfor ~ \nexpr ~ \kin ~ \nexpr ~ \kcolon ~ \mul{\nstmt} ~ \op{(\kelse ~ \kcolon ~ \mul{\nstmt})}& \desc{ForLoop} \\
  & $|$ & \kwhile ~ \sparen{\nexpr} ~ \kcolon ~ \mul{\nstmt} ~ \op{(\kelse ~ \kcolon ~ \mul{\nstmt})}& \desc{WhileLoop} \\
  & $|$ & \kif ~ \sparen{\nexpr} ~ \kcolon ~ \mul{\nstmt} ~ \op{(\kelse ~ \kcolon ~ \mul{\nstmt})}& \desc{If} \\
  & $|$ & \optypcomm ~ \kwith ~ \mul{\nwithitem} ~ \kcolon ~ \mul{\nstmt} & \desc{With} \\
  & $|$ & \kimport ~ \mul{\nalias} & \desc{Import} \\
  & $|$ & \kfrom ~ \nint ~ \op{\nid} \kimport ~ \mul{\nalias} & \desc{ImportFrom} \\
  & $|$ & \nexpr & \desc{ExprStmt} \\
\end{tabular}

\begin{tabular}{lrll}
  \nexpr & ::= & \nexpr ~ \nboolop ~ \nexpr & \desc{BoolOp} \\
  & $|$ & \nexpr ~ \nbinop ~ \nexpr & \desc{BinaryOp} \\ 
  & $|$ & \nunop ~ \nexpr & \desc{UnaryOp} \\ 
  & $|$ & \lparen{\mul{\nexpr}} & \desc{List} \\ 
  & $|$ & \sparen{\mul{\nexpr}} & \desc{Tuple} \\ 
  & $|$ & \nexpr ~ \mul{(\ncompop ~ \nexpr)} & \desc{CompOp} \\
  & $|$ & \nexpr ~ \sparen{\mul{\nexpr} \mul{\nkeyword}} & \desc{Call} \\
  & $|$ & \nconstant & \desc{Constant} \\
  & $|$ & \nexpr {\tt .}\nid& \desc{Attribute} \\
  & $|$ & \nexpr\lparen{\nexpr} & \desc{Subscript} \\
  & $|$ & \nid & \desc{Name} \\

  \nboolop & ::= & \oand ~ $|$ ~ \oor & \desc{BoolOperator} \\
  \nbinop & ::= & \oand ~ $|$ ~ \osub ~ $|$ ~ \omul & \desc{BinOperator} \\
  \nunop& ::= & \kinvert ~ $|$ ~ \knot ~ $|$ ~ \oadd ~ $|$ ~ \osub & \desc{UnOperator} \\
  \ncompop& ::= & \oeq ~ $|$ ~ \oneq ~ $|$ ~ \olt ~ $|$ ~ \olte ~ $|$ ~ \ogt ~ $|$ ~ \ogte ~ $|$ ~ \ois ~ $|$ ~ \onis ~ $|$ ~ \oin ~ $|$ ~ \onin & \desc{CompOperator}\\
  \nargs & ::= & \mul{(\narg ~ \op{(\oassign ~ \nexpr)})}, ~ \mul{(\narg ~ \op{(\oassign ~ \nexpr)})}, ~ \op{\narg}, ~ \mul{(\narg ~ \op{(\oassign ~ \nexpr)})}, ~ \op{\narg} & \desc{Arguments}\\
  \narg & ::= & \nid ~ \op{\nexpr}~\op{\nstr} & \desc{Argument} \\
  \nkeyword & ::= & \op{\nid} \oassign \nexpr & \desc{Keyword} \\ 
  \nalias & ::= & \nid ~\mul{(.\nid)} \op{(\kas ~ \nid)} & \desc{Alias} \\
  \nwithitem & ::= & \nexpr ~ \op{(\kas ~ \nexpr)} & \desc{WithItem}\\
\end{tabular}

\begin{tabular}{lrll}
  \nconstant & ::= & \knone & \desc{NoneLiteral} \\
  & $|$ & \nint & \desc{IntLiteral} \\
  & $|$ & \nfloat & \desc{FloatLiteral} \\
  & $|$ & \ncomplex & \desc{ComplexLiteral} \\
  & $|$ & \nstr & \desc{StringLiteral} \\
  & $|$ & \nbool & \desc{BooleanLiteral} \\
  & $|$ & \sparen{\mul{\nconstant}} & \desc{TupleLiteral} \\
  & $|$ & {\tt ...} & \desc{Ellipsis} \\
  \ntypignore & ::=  & \mul{\nint} & \desc{TypeIgnore} \\
  \nid & $\in$ & \did \\
  \nstr & $\in$ & \dstr \\
  \nbool & $\in$ & \{{\tt True}, {\tt False}\}\\
  \nint & $\in$ & $\mathbb{Z}$ \\
  \nfloat & $\in$ & $\mathbb{R}$ \\
  \ncomplex & $\in$ & $\mathbb{C}$ \\
\end{tabular}

Expressions are parts of the code that evaluates to a value.
Python has 5 kinds of primitive values, 
which are numbers, strings, booleans, the value {\itshape None} and {\itshape Ellipsis}.
The value None is used to denote a undefined value,
similar to the value {\itshape null} in Java.
The value Ellipsis corresponds to the notation ``...",
which can be used as an special placeholder meaning expansion of the sequence. 
Python has composite types of tuple, list, set, map, and custom classes.
The expression syntax defines ways to build up values
and complex expressions such as operators, comprehension, and function calls. 

Statements are parts of the code that changes the program state,
such as variable binding or control flow. 
Python statements are categorized into 
simple statements which denote a single state changing step, 
or compound statements which are composed of multiple statements.

Simple statements include assignment statements and import statements.
Assignment statements are used to declare a new variable and its value
or update a variable value.
Import statements are used to specify a module, load it
and get definitions of the module into current namespace.
In import statements, each target module and its aliased name is represented
as alias.   
Note that procedure call is a special case of expression statements,
where the expression is a function call.

Compound statements include conditional statements, loop statements,
and definitions for functions and classes.
Additionally, the with statement is an special kind of compound statement.
With statement is identical to the assignment statement 
in a way that it binds an expression to a name, 
but the statement additionally adds implicit calls
to the object's methods related to initialization and destruction.
Similar to the alias in import statement,
with statements use WithItem to represent then ame and expression.

Top-level components are representation of the program
in different execution environment of the Python interpreter.
For example, a module represents a Python code file, composed of
multiple definitions speicified of statements. 
The full Python abstract syntax is attched in the supplementary material.

\subsection{Training API Patterns for TensorFlow ML model}

Before we define transformation rules for TensorFlow models,
we categorize the model training codes by their API usage pattern.
TensorFlow library provides various methods for training process.

\lstinputlisting[language=Python, caption=Training API usage example]
{pattern_ex.py}

The above figure illustrates two different API usage for model training.
Line 7 to 16 uses low-level APIs to manually compute the training loss.
In line 10, the tf.GradientTape object is instantiated by `with' statement.
Inside the `with' statement, a prediction loss is computed against
a given training data.
The GradientTape object records the computaions occur inside the scope
and later the gradient can be computed with `gradient()' method call.
Then the model parameters are optimized against the gradient
by the method `apply\_gradients'.
The training step is manually repeated by `for' loop in line 8,
where each training data is taken from the `tf.data.Dataset` instance.

Line 18 to 20 uses high-level APIs of `tf.keras.Model' class for training.
The `compile' method in line 19 assigns the optimizer and loss
function to the training configuration.
The `fit' method then invokes the training process in one line.
The method automatically feed the training data to the model,
compute the loss, and apply the gradients to model parameters.

While both code fragments trains the model in a same way, 
the code structures significantly differ.
Using high-level APIs simplifies the program,
reducing additional codes that compute the prediction loss and apply gradients.
Low-level APIs are verbose, however, developer can fully control
the training process.

Different training APIs require different transformation rules.


\subsection{Transformation Rule for Distributed TensorFlow ML model}

In this section, we describe the transformation rule that
transforms single-GPU based TensorFlow model codes into
multi-GPU based TensorFlow model codes.
We informally understand code transformation rule as
conditions to select the target code parts
and methods to actually transform them into another.
The methods include addition, modification, and deletion of
specific code parts.
Currently, code transformation for distributed ML training
is only described by set of examples and informal explanations.
In order to automate the code transformation process,
we need to formally define the code transformation rule
and ways to convert the definition into software implementation.
We propose a formal definition of code transformation rule
for distributed ML training, and implement the automatic code transformation
software based on the formal definition.

Code transformation is formally defined as a pure function from AST to AST.
AST is an abbreviation of abstract syntax trees; it is a tree data structure
that represents grammatical structure of the program code.
We call this function a transform function.
We may define multiple transform functions that act on different kinds
of AST and use them to define other transform functions.
For example, in order to transform a Python code into another,
we define a transform function that takes Module AST and returns Module AST.
Inside the Module transform function definition,
we may use Statement transform function to transform statements
that compose the Module AST.

Together with the AST parameter, transform functions take and return
the environment parameter.
Environment parameters are used to store specific identifiers
and pass it to the other calls of the transform function.
For example, statement transform function frequently use 
the identifier bound to the TensorFlow module.
The module name first appears from the import statement.
The transform function call on the import statement stores
the TensorFlow module name on the environment and returns it.
Then the later function calls to other statements can
retrieve the TensorFlow module name from the environment parameter.

We define the transform function in terms of pattern matching on input AST.
The pattern matching is used to match the kind and content of the input AST
and construct an output AST.

% explain how transform function works by example
% ISSUE : should remove `import tensorflow as tf` ?

\begin{lstlisting}[language=Python, caption = Original code example]
import tensorflow as tf
import tensorflow.keras as keras

optimizer = keras.optimizers.Adam(lr)
\end{lstlisting}

\begin{lstlisting}[language=Python, caption = Transformed code example]
import tensorflow as tf
import horovod.tensorflow as hvd
hvd_broadcast_done = False
hvd.init()
gpus = tf.config.experimental.list_physical_devices('GPU')
for gpu in gpus:  tf.config.experimental.set_memory_growth(gpu, True)
if gpus:  tf.config.experimental.set_visible_devices(gpus[hvd.local_rank()], 'GPU')
import tensorflow.keras as keras

optimizer = keras.optimizers.Adam(lr * hvd.size())
optimizer = hvd.DistributedOptimizer(optimizer)
\end{lstlisting}

We first describe how the transform function works by example.
The above figures illustrate a pair of TensorFlow model codes
before and after the transformation.


\begin{itemize}
  \item show module AST of the original code
  \item explain module AST == list of Stmt AST
  \item show module AST transform function, passing env
  \item show Stmt transform function for import \& Alias transform function
  \item show how pattern matching is used
  \item show keras identifier is stored in env
  \item show Stmt transform funciton for assignstmt
  \item show how pattern guard is additionally used
  \item show how pattern matched variables are used
  \item conclude with how output module AST is constructed
\end{itemize}

The above figure illustrates the example of a statement transformation.
Intutitive understanding of the transformation is as follows:
if the input code is assignment statment 
that assigns a new `tf.keras.optimizer.Adam' instance,
then multiply `hvd.size()' on learning rate argument expression of the
instance constructor function.
The transform function should describe two aspects of the sentence;
first it should describe the condition of "assignment statement that
creates `tf.keras.optimizer.Adam' instance";
second it should describe the transformation sentence
of "multiply `hvd.size()' on the learning rate argument". 

(TODO figure of part of transform function describing the example) 

The figure defines the part of Statement transform function. 
The pattern matched by the function is described on the first line;
it matches the assignment statements with operator `=' and
right-hand side of function call expression.
Note that the input AST components are matched onto pattern variables.
This allows the definition to reuse the input AST component
when constructing the output AST.
The second line illustrates pattern guard that matches the input AST content.
It checks the callee expression is the expression `tf.keras.optimizers.Adam'.
The pattern guard uses the environment parameter $\sigma$ to retrieve
module name for the Keras module.

The figure defines the following part of the function.
It describes the construction of an output AST and environment.
The output AST is assignment statement which
the right-hand side function argument expression is modified.
As previously mentioned, the construction use pattern matched variables
to reuse the input AST components.
The difference is that first argument expression is multiplied by `hvd.size()',
which formally describes the transformation sentence.

We describe the transform function definition.
\begin{itemize}
  \item explain types and aux functions
  \item explain trans Module/Stmt list (env passing \& concating the results
  \item explain trans Stmt (pattern match \& pattern guard)
  \item explain trans Expr (recursively check all expr in code)
  \item explain trans Alias \& WithItem (stores id on env)
\end{itemize}

We inspected multiple references to define the whole transform function.
Horovod documentation\cite{horovodtf} describes the code modification
required to change trainig script. It describes six steps to modify
existing training scripts to distributed training scripts. 
In addition to 

