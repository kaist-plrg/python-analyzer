\section{Class hierarchy analysis}\label{sec:cha}

When developing TensorFlow DL models, user-defined classes can
inherit TensorFlow library classes. 
This allows developers to extend the methods and behaviors of TensorFlow
library classes without directly modifying the library codes. 
Figure \ref{fig:cha:tfex}(a) shows an example of TensorFlow DL model
code using an user-defined class.
In line 4, the newly defined class {\tt ResNet} inherits the TensorFlow
library class, {\tt keras.Model}.
The {\tt keras.Model} class represents a model object composed of multiple
layers, and provides trainig-related methods such as {\tt compile} or {\tt fit}.
By inheriting the {\tt keras.Model} class, the {\tt ResNet} class
can also utilize the training-related methods while defining the new model
structure.
Line 8 creates a {\tt ResNet} class instance {\tt model}.
Then the line 9 calls the {\tt fit} method which is inherited from the
{\tt keras.Model} class.
By calling the {\tt fit} method, the model instance can be autoamtically
trained without manually repeating the training steps.

\begin{figure}[!ht]
  \centering
  \begin{subfigure}[t]{0.35\textwidth}
    \begin{lstlisting}[language=Python]
from tensorflow import keras

# `ResNet` inherits `keras.Model`
class ResNet(keras.Model): 
    def __init__(self, block_list):
        ...

model = ResNet([2,2,2])
model.fit(x_train, y_train)\end{lstlisting}
    \caption{Single-GPU-based DL model example using an user-defined class}
  \end{subfigure}
  \hspace{3mm}
  \begin{subfigure}[t]{0.6\textwidth}
    \begin{lstlisting}[language=Python]
from tensorflow import keras
import horovod.tensorflow.keras as hvd

class ResNet(keras.Model):
    def __init__(self, block_list):
        ...

model = ResNet([2,2,2])

model.fit(
    x_train, 
    y_train,
    callbacks=[hvd.callbacks.BroadcastGlobalVariablesCallback(0)])\end{lstlisting}
    \caption{Distributed model example using an user-defined class}
  \end{subfigure}

  \caption{Code example of distributing a model using an user-defined class}
  \label{fig:cha:tfex}
\end{figure}

To correctly transform TensorFlow DL models into the distributed models,
the transformation must recognize the user-defined classes that inherits
TensorFlwo classes.
Figure \ref{fig:cha:tfex}(b) is an example of modifying the code in 
\ref{fig:cha:tfex}(a) into a distributed model code.
Line 9 of \ref{fig:cha:tfex}(a) is modified as line 10 to 13 of 
\ref{fig:cha:tfex}(b). The modification adds a keyword argument {\tt callbacks}
to the {\tt fit} method call. 
To correctly modify the example code, the transformation must recognize the 
the line 9 of \ref{fig:cha:tfex}(a) calls the {\tt fit} method which originates
from the {\tt keras.Model} class.
Without recognizing the inheritance relation between {\tt ResNet} and
{\tt keras.Model}, the transformation module cannot correctly recognize
and modify the method call in line 9.  

To solve this problem, we employ the class hierarchy analysis as a pre-analysis
to analyze the class inheritance relation between user-defined classes
and TensorFlow classes.
\textit{Class hierarchy analysis} is a static analysis technique that identifies
inheritance relation between classes appear in the code.
By class hierarchy analysis on the input DL model code,
we can identify user-defined classes that inherit TensorFlow classes,
and therefore correctly identify training-related method calls.
In figure \ref{fig:cha:tfex}(a), for instance, 
the class herarchy analyzer reads line 4 to conclude that the user class
{\tt ResNet} is a subclass of {\tt keras.Model}.
The analysis result is sent to the later transformation stage,
which allows the transformation to recognize the {\tt fit} method
target in line 9 is inherited from the superclass, {\tt keras.Model}.
