\section{Class hierarchy analysis}\label{sec:cha}

In TensorFlow models, user-defined classes can inherit 
TensorFlow library classes to extend the training-related methods 
to avoid re-implementing them.
Figure \ref{fig:cha:tfex:a} shows a code example of using an user-defined class
that inherits the TensorFlow library class.
In line 4, the user-defined class {\tt ResNet} inherits the TensorFlow
library class {\tt keras.Model}.
By inheriting the {\tt keras.Model} class, the {\tt ResNet} class
defines a new model structure while reusing the methods 
defined in the {\tt keras.Model} class.
Then line 9 calls the {\tt fit} method, inherited from the {\tt keras.Model} 
class. The {\tt fit} methods trains the model with the training dataset 
given as arguments.

\begin{figure}[!ht]
  \centering
  \begin{subfigure}[t]{0.35\textwidth}
    \begin{lstlisting}[language=Python]
from tensorflow import keras

# `ResNet` inherits `keras.Model`
class ResNet(keras.Model): 
    def __init__(self, block_list):
        ...

model = ResNet([2,2,2])
model.fit(x_train, y_train)\end{lstlisting}
    \caption{Single-GPU-based DL model example using an user-defined class}
    \label{fig:cha:tfex:a}
  \end{subfigure}
  \hspace{3mm}
  \begin{subfigure}[t]{0.6\textwidth}
    \begin{lstlisting}[language=Python]
from tensorflow import keras
import horovod.tensorflow.keras as hvd

class ResNet(keras.Model):
    def __init__(self, block_list):
        ...

model = ResNet([2,2,2])

model.fit(
    x_train, 
    y_train,
    callbacks=[hvd.callbacks.BroadcastGlobalVariablesCallback(0)])\end{lstlisting}
    \caption{Distributed model example using an user-defined class}
    \label{fig:cha:tfex:b}
  \end{subfigure}

  \caption{Code example of distributing a model using an user-defined class}
  \label{fig:cha:tfex}
\end{figure}

The training API pattern identifier and the AST transformer require
class inheritance relationship to recognize the training-related methods.
Figure \ref{fig:cha:tfex:b} is an example of modifying the code in 
\ref{fig:cha:tfex:a} into the distributed model.
The line 9 of \ref{fig:cha:tfex:a} is modified as the lines 10 to 13 of 
\ref{fig:cha:tfex:b}. The modification adds the keyword argument 
{\tt callbacks} to the {\tt fit} method call. 
To apply this modification, we must first recognize that the {\tt fit} method
in the line 9 of \ref{fig:cha:tfex:a} is inherited from the
{\tt keras.Model} class.
Without recognizing the inheritance relation between {\tt ResNet} and
{\tt keras.Model}, we cannot identify the training method call 
in the line 9.  

We employ the class hierarchy analysis as a pre-analysis to solve this problem. 
\textit{Class hierarchy analysis} is a static analysis technique that identifies
inheritance relation between the classes in the code.
By applying class hierarchy analysis on the input DL models,
we can identify which user-defined classes inherit TensorFlow library classes,
and therefore correctly identify the training-relate
method calls inherited from TensorFlow library classes.
In the figure \ref{fig:cha:tfex:a}, for instance, 
the class hierarchy analyzer reads the line 4 to conclude that the class
{\tt ResNet} inherits the class {\tt keras.Model}.
This information is sent to the training API pattern identifier and 
AST transformer so that they can recognize the {\tt fit} method in line 9 
as the call to the training method. 
