\section{Class hierarchy analysis}\label{sec:cha}

\subsection{Motivation}

To correctly transform TensorFlow DL model codes,
one must identify the TensorFlow training APIs used in the training code.
This includes statements that create and use instances of TensorFlow classes or
calls methods of TensorFlow classes. 
For instance, a developer can define a DL model by creating an instance of
{\tt tf.keras.Sequential} class and train it by calling the
{\tt fit} method on the model instance.
Figure \ref{fig:cha:tfex} shows an example of using
TensorFlow classes and methods.
Line 4 creates an instance of {\tt keras.models.Model} class by using
{\tt keras.Sequential} API, and line 5 calls the {\tt fit} method
of the instance to train the model.

\begin{figure}[h]
\begin{lstlisting}[language=Python]
import tensorflow as tf
import tensorflow.keras as keras

model = keras.Sequential(...) # define a model
model.fit() # train the model by calling 
\end{lstlisting}
  \caption{Training code example of using TensorFlow library class and method}
  \label{fig:cha:tfex}
\end{figure}

In practice, developers may want to extend or modify original behaviors
of TensorFlow library classes or methods.  
Developers can define a new class that inherits TensorFlow library classes
and override methods to extend their behaviors. 
These \textit{user-defined training classes}
should also be identified to prepare a correct transformation rule 
for different implementations.  However, using only syntactic information 
cannot fully identify user-defined training classes
as different developers use different identifiers for naming classes.
Figure \ref{fig:cha:ex} shows an instance of using the
user-defined training class, the {\tt ResNet} class inheriting
the {\tt keras.models.Model} class.
The selection of the name {\tt ResNet} here is completely arbitrary;
it can be any other name that cannot be fully recognized by
pre-defined syntactic rules.
Identifying the method name {\tt fit} is also not a correct method.
Line 12 of figure \ref{fig:cha:ex} defines another class {\tt Something}
that has a method {\tt fit} but is not related to the training.
Using the method name to identify the traninig API will lead to
incorrectly assuming that the instance {\tt something} in line 20
is the TensorFlow model instance, hence resulting in incorrect transformation.

\begin{figure}[h]
  \begin{lstlisting}[language=Python]
import tensorflow as tf
import tensorflow.keras as keras

# user-defined training class
class ResNet(keras.models.Model): 
    def __init__(self, layer_num, **kwargs):
        pass
    def call(self, inputs):
        pass

# arbitrary non-training class 
class Something():
    def fit(optimizer, y):
        print("hello, world!") 

if __name__ = '___main__': 
    # actual DL model instance
    model = ResNet(50)
    # object not related to training
    something = Something()

    model.build(input_shape=(None,) + c.input_shape) 
    optim = tf.keras.optimizers.SGD()

    # training-related method call, which should be transformed
    model.fit(optimizer=optim, train_data) 
    # method call not related to the training  
    something.fit(optimizer=optim, train_data)
\end{lstlisting}
\caption{Training code example of using a user-defined class}
\label{fig:cha:ex}
\end{figure}

To solve this problem, we devised to pre-analyze the class inheritance
relation between TensorFlow library classes and user-defined classes. 
We utilize a \textit{class hierarchy analysis}, a type of static analysis
that identifies the inheritance relations between the classes appearing
in the code.
The class hierarchy analysis result stores the inheritance relation
which is used in later stages of the transformation.


\subsection{Class Hierarchy Analyzer} 

(TODO: simply explain how cha works on our approach, and remove 'graph')
The class hierarchy analyzer(CHA) module analyzes the
subclass relationship between the 
user-defined classes and TensorFlow classes.
The module returns a class hierarchy graph as an output.

The CHA module gets a model code package as an input
and creates the model package CHG as an output.
The analysis iterates over the files in the package
and extracts every subclass information available in each file.
New Python classes are defined with the {\tt class} statements.
In {\tt class} statements, the newly defined class can
inherit another class by specifying the class expression
in the argument position.
The analyzer finds all {\tt class} statements from the module AST,
adds the CHG node for the new class. The analyzer also adds an edge
to the parent class node if the {\tt class} statement specifies an inheritance.
