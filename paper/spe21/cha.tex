\section{Class hierarchy analysis}\label{sec:cha}

\subsection{Class Hierarchy Analyzer}

In TensorFlow model codes, \textit{user-defined classes} inherit
TensosFlow library classes to reuse and extend training-related methods.
The {\tt keras.layers.Layer} and {\tt keras.models.Model} classes 
are typical examples of the case.
The {\tt keras.layers.Layer} is a base class for
layers that define parts of the ML model computation.
Subclasses of the {\tt keras.layers.Layer} can extend
the {\tt call} method to define the forward propagation
and automatically support gradient updates.
The {\tt keras.model.Model} is a base class for models.
Subclasses of the {\tt keras.models.Model} can extend
the {\tt call} method to define the model blocks
and automatically support training-related methods
such as {\tt fit} or {\tt save}. 

\begin{figure}[h]
\lstinputlisting[language=Python]{subclass_ex.py}
\caption{Training code example of using a user-defined class}
\label{fig:cha:ex}
\end{figure}

The figure \ref{fig:cha:ex} illustrates an example of a training code
utilizing the user-defined class. 
Line 4 defines a new class {\tt ResNet} that inherits the  
{\tt keras.models.Model} class. The instance of {\tt ResNet}, {\tt model}
is created at line 11. Although the {\tt ResNet} class does not define
the method {\tt fit}, line 14 calls the {\tt fit} method to train the model.
Because the {\tt fit} method is inherited from the {\tt Model} class,
the {\tt ResNet} instance can invoke the training process with
{\tt model.fit}. The inherited model {\tt fit}
automatically repeats the gradient descent with
given model computation and training data. 

To correctly transform training codes using user-defined classes,
the subclass relationship between user-defined classes
and TensorFlow classes should be known before the training API pattern analysis. 
In the figure \ref{fig:cha:ex}, for instance, 
the fact that the {\tt ResNet} class
is subclass of the {keras.models.Model} is essential to identify
that the code uses a high-level API in {\tt tf.keras} module. 
Otherwise the function call {\tt model.fit} in line 14 would
recognized as an ordinary function call not related to the training pattern.

\begin{figure}[h]
\begin{lstlisting}[language=Python]
class A:
  pass

class B(A): # inherits A
  pass

class C(B): # inherits B
  pass

c = C()
isinstance(c, A) # returns True
\end{lstlisting}
\caption{Code example of Python class inheritance}
\label{fig:cha:pythonex}
\end{figure}

The class hierarchy analyzer(CHA) module analyzes the
class subclass relationship between the 
user-defined classes and TensorFlow classes.
The module returns a class hierarchy graph(CHG) as an output.
A CHG is a directed graph structure that represents the class hierarchy.
Each node in the graph represents a class,
and each directed eadge represents a class inheritance,
where the start node indicates the child class
and the end node indicates the parent class.
Consider the example in figure \ref{fig:cha:pythonex}.
The class B is a subclass of the class A, and the class C is a subclass of the
class C.
This subclass relationship will represented as a CHG with three node,
each corresponding to a class A, B, or C.
Suppose the node A corresponds to the class A and node B corresponds to
the class B.
If there is a (directed) path from the node A to the node B in CHG,
then the class A is a subclass of the class B.

The CHA module gets a model code package as an input,
and creates the model package CHG as an output.
The analysis iterates over the files in the package,
and extract every subclass information available in each file.
New Python classes are defined with the {\tt class} statements.
In {\tt class} statements, newly defined class can
inherit another class by specifing the class expression
in the argument position.
The analyzer finds all {\tt class} statements from the module AST,
add the CHG node for the new class. The analyzer also adds an edge
to the parent class node if the {\tt class} statement specifies an inheritance.

After CHGs for all model code files are generated, 
they are merged into one CHG.
One caveat in the process is correct translation of class names
of submodules in the package.
The Python packaging system is closely related with the file system.
A package is specified by a directory; 
the directory name is the package name, 
and Python code files in the directory is the modules included in the package.
A package can include subpackages, which is specified
by the subdirectories, and modules in the subpackages are called submodules.
A module can access to a module in the subpackage by a qualified name,
which prefixes describe subpackage path to the target module.
This means that a same class should be specified by different qualified
names in perspectives of different subpackages.
The analyzer should also take account of the qualified names
in merging CHGs of the submodules. 
When a node in the submodule CHG is merged into the parent module CHG,
the class qualified name of the node should be prefixed with the
submodule name.

\subsection{Implementation}
We implemented the CHG merging algorithm that constructs a correct
qualified name, and utilized it when the CHA produces the CHG for
a Python package. 

The CHA module produces a CHG for the model package and deliever to
other modules. Given the CHG, a module can compute whether a class is
subclass of another by finding path in the graph.
We implemented the CHG as a class and path-finding algorithm as
a method for the class. The path-finding algorithm is based on
a recursive depth-first search.


