\section{Class hierarchy analysis}\label{sec:cha}

\subsection{Class Hierarchy Analyzer}

In TensorFlow model codes, \textit{user-defined classes} inherit
TensorFlow library classes to reuse and extend training-related methods.
The {\tt keras.layers.Layer} and {\tt keras.models.Model} classes 
are typical examples of the case.
The {\tt keras.layers.Layer} is a base class for
layers that define parts of the ML model computation.
Subclasses of the {\tt keras.layers.Layer} can extend
the {\tt call} method to define the forward propagation
and automatically support gradient updates.
The {\tt keras.model.Model} is a base class for models.
Subclasses of the {\tt keras.models.Model} can extend
the {\tt call} method to define the model blocks
and automatically support training-related methods
such as {\tt fit} or {\tt save}. 

\begin{figure}[h]
\lstinputlisting[language=Python]{subclass_ex.py}
\caption{Training code example of using a user-defined class}
\label{fig:cha:ex}
\end{figure}

Figure \ref{fig:cha:ex} illustrates an example of a training code
utilizing the user-defined class. 
Line 4 defines a new class {\tt ResNet} that inherits the  
{\tt keras.models.Model} class. The instance of {\tt ResNet}, {\tt model}
is created at line 11. Although the {\tt ResNet} class does not define
the method {\tt fit}, line 14 calls the {\tt fit} method to train the model.
Because the {\tt fit} method is inherited from the {\tt Model} class,
the {\tt ResNet} instance can invoke the training process with
{\tt model.fit}. The inherited model {\tt fit}
automatically repeats the gradient descent with
given model computation and training data. 

To correctly transform training codes using user-defined classes,
the subclass relationship between user-defined classes
and TensorFlow classes should be known before the training API pattern analysis. 
In figure \ref{fig:cha:ex}, for instance, 
the fact that the {\tt ResNet} class
is a subclass of the {keras.models.Model} is essential to identify
that the code uses a high-level API in {\tt tf.keras} module. 
Otherwise the function call {\tt model.fit} in line 14 would
be recognized as an ordinary function call not related to the training pattern.

\begin{figure}[h]
\begin{lstlisting}[language=Python]
class A:
  pass

class B(A): # inherits A
  pass

class C(B): # inherits B
  pass

c = C()
isinstance(c, A) # returns True
\end{lstlisting}
\caption{Code example of Python class inheritance}
\label{fig:cha:pythonex}
\end{figure}

The class hierarchy analyzer(CHA) module analyzes the
class subclass relationship between the 
user-defined classes and TensorFlow classes.
The module returns a class hierarchy graph(CHG) as an output.
A CHG is a directed graph structure that represents the class hierarchy.
Each node in the graph represents a class,
and each directed edge represents a class inheritance,
where the start node indicates the child class
and the end node indicates the parent class.
Consider the example in figure \ref{fig:cha:pythonex}.
Class B is a subclass of class A, and class C is a subclass of 
class C.
This subclass relationship is represented as a CHG with three nodes,
each corresponding to a class A, B, or C.
Suppose node A corresponds to class A and node B corresponds to
class B.
If there is a (directed) path from node A to node B in CHG,
then class A is a subclass of class B.

The CHA module gets a model code package as an input
and creates the model package CHG as an output.
The analysis iterates over the files in the package
and extracts every subclass information available in each file.
New Python classes are defined with the {\tt class} statements.
In {\tt class} statements, the newly defined class can
inherit another class by specifying the class expression
in the argument position.
The analyzer finds all {\tt class} statements from the module AST,
adds the CHG node for the new class. The analyzer also adds an edge
to the parent class node if the {\tt class} statement specifies an inheritance.

After CHGs for all model code files are generated, 
they are merged into one CHG.
One caveat in the process is a correct translation of class names
of submodules in the package.
The Python packaging system is closely related to the file system.
A package is specified by a directory; 
the directory name is the package name, 
and the Python code files in the directory are the modules included in the package.
A package can include subpackages, which are specified
by the subdirectories, and modules in the subpackages are called submodules.
A module can access a module in the subpackage by a qualified name
which prefixes describe the subpackage path to the target module.
This means that the same class should be specified by different qualified
names in perspectives of different subpackages.
The analyzer should also take account of the qualified names
in merging CHGs of the submodules. 
When a node in the submodule CHG is merged into the parent module CHG,
the class qualified name of the node should be prefixed with the
submodule name.

\subsection{Implementation}
We implemented the CHG merging algorithm that constructs a correct
qualified name, and utilized it when the CHA produces the CHG for
a Python package. 

The CHA module produces a CHG for the model package and delivers it to
other modules. Given the CHG, a module can compute whether a class is
a subclass of another by finding the path in the graph.
We implemented the CHG as a class and the path-finding algorithm as
a method for the class. The path-finding algorithm is based on
a recursive depth-first search.


