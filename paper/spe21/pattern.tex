\section{Training API Pattern Analysis}\label{sec:pattern}

\subsection{TensorFlow ML Training API Patterns}

\lstinputlisting[language=Python]
{pattern_ex.py}

TensorFlow provides various APIs to define the training process.
The above figure illustrates two examples of using 
different APIs for the model training.
Line 2 to 10 uses low-level APIs to repeat training steps over the training
data set. Inside the {\tt for} loop, 
the code uses the {\tt GradientTape} instance to record the loss computation,
then uses the {\tt gradient} method and the {\tt apply\_gradient} method to
back-propagate the gradient to the model parameters.
In contrast, line 13 and 14 uses high-level APIs to automatically
invoke the model training process by two methods calls, {\tt compile} and
{\tt fit}. The {\tt fit} method repeats a same process with the {\tt for}
loop in line 2; it takes each training data from the set and
applies the gradient to the model parameter.

While both code fragments train the model in a same way, 
the code structures significantly differ.
Using high-level APIs simplifies the program,
reducing additional codes that compute the prediction loss and apply gradients.
Low-level APIs are verbose, however, developer can fully control
the training process.
Developers can freely choose from different training code styles to
take advantage of each way.

To correctly transform the training codes,
the transform software must transform different training APIs
based on different transformation rules. 
We implemented a \textit{API pattern analysis} that identifies
the TensorFlow API usage with \textit{training API patterns} 
Each training API pattern is a set of code patterns for AST,
and code patterns are ASTs with
special holes that are later matched with concrete value.
When a code pattern is matched against a code AST,
it succeeds with the holes matched with the AST subnodes,
or fails to match the given AST.
The software matches a training API pattern to the target training code,
and if the match succeeds, the corresponding transformation rule
is used to transform the training code.

We manually inspected multiple TensorFlow training codes to identify
common patterns of training-related API usage. 
In this end, we defined four training API patterns
that effectively identify kinds of training APIs usage in the target code.
The figure \ref{tab:patterns} briefly explains each training API pattern.
Note that each pattern are assigned with different TensorFlow versions.
The transformation software also supports legacy training codes
that use compatibility module for TensorFlow version 1.x.

\begin{figure}
  \centering
  \begin{tabular}{|c|c|l|}
    \hline
    TF version & Pattern name & Explanation \\
    \hline
    1.x & Session & Low-level training API using {\tt Session} instance\\
    \hline
    1.x & MonitoredSession & Low-level training API using {\tt MonitoresSession} instance \\
    \hline
    2.x & GradientTape & Low-level training API using {\tt GradientTape} instance\\
    \hline
    2.x & Keras & High-level training API using {\tt fit} method of {\tt keras.models.Model} instance\\
    \hline
  \end{tabular}
  \caption{Training API patterns}
  \label{tab:patterns}
\end{figure}

We now explain each traing API pattern with concrete code examples.

\textbf{Session Pattern} 
In TensorFlow 1.x, the {\tt tensorflow.Session} instance provides methods to
invoke computations on the computation graph.
Developers use the {\tt run} method to run the optimization on the model,
usually inside the {\tt for} loop to repeat the process with training data.
The Session pattern matches call expressions that the function
call expression is the method {\tt tensorflow.Session.run}.

\begin{figure}
\begin{lstlisting}[language=Python]
with tf.Session() as sess:
    for step in xrange(int(num_epochs * train_size) // BATCH_SIZE):
      sess.run(optimizer, feed_dict=feed_dict)
\end{lstlisting}
\caption{Session pattern code example}
\end{figure}

\textbf{MonitoredSession Pattern}
The {\tt MonitoredSession}


\subsection{Implementation}

We implemented the training API using pattern matching.

\begin{itemize}
  \item how API patterns correspond to Scala pattern matching
  \item "Summary" based implementation explanation 
  \item when making function summary, return class also
\end{itemize}
